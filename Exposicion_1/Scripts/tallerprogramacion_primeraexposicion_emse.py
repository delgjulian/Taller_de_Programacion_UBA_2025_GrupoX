# -*- coding: utf-8 -*-
"""TallerProgramacion_PrimeraExposicion_EMSE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OxOPEMZh0MJn-GamPe3dtmy4Fa0rnDcq
"""

"""
Análisis exploratorio de la Encuesta Mundial de Salud Escolar (EMSE 2018) – Argentina
Taller de Programación | Maestría en Finanzas – UBA | Primera exposición grupal

Este script realiza la limpieza, exploración y análisis descriptivo inicial de la base de microdatos
de la EMSE 2018, publicada por el Ministerio de Salud de la Nación.
El objetivo es comprender la estructura de la base, identificar variables relevantes
(asociadas a hábitos de salud, consumo de tabaco y alcohol, actividad física, alimentación, etc.)
y generar visualizaciones básicas para la presentación grupal del curso.

Estructura general:
1. Carga y detección de codificación del archivo CSV.
2. Corrección de caracteres mal decodificados.
3. Análisis de valores faltantes y filtrado de variables completas.
4. Integración con el libro de códigos para generar un diccionario de variables.
5. Construcción de un subconjunto temático (salud y hábitos).
6. Análisis descriptivo y visualizaciones.

Autores: Julián Delgadillo Marín, Alejandro Alcocer, Christian Campos
Fecha: 5 de Noviembre 2025
"""

# Subir el archivo al entorno de Colab (Base de datos)
from google.colab import files
uploaded = files.upload()

# Cargar la base de datos
import pandas as pd

# Cargar el CSV (ajusta el nombre si es distinto)
df = pd.read_csv("EMSE_DatosAbiertos.csv", encoding='latin1')  # a veces 'utf-8' o 'latin1' según acentos

# Exploración inicial

# Ver las primeras filas
df.head()

# Dimensiones del dataset
print("Filas:", df.shape[0], "Columnas:", df.shape[1])

# Información general
df.info()

# Estadísticos básicos
df.describe(include='all').transpose().head(10)

# Ver las primeras columnas
df.columns[:30]

# Examinar una muestra de respuestas textuales:
df[['texto_q1','texto_q2','texto_q3']].head(10)

# Detectar encoding real
!pip install chardet
import chardet

with open("EMSE_DatosAbiertos.csv", 'rb') as f:
    result = chardet.detect(f.read(200000))
result

# Bloque para limpiar caracteres mal decodificados: Función para corregir los textos dañados
def fix_encoding(s):
    if isinstance(s, str):
        return s.encode('latin1', errors='ignore').decode('utf-8', errors='ignore')
    return s

# Aplicar la corrección a todas las columnas tipo texto
df = df.applymap(fix_encoding)

# Verificamos las tres primeras variables
df[['texto_q1', 'texto_q2', 'texto_q3']].head(10)

# Paso 4 – Revisión de valores faltantes
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
sns.heatmap(df.isnull(), cbar=False)
plt.title("Mapa de valores faltantes - EMSE 2018")
plt.show()

# Conteo numérico de missing
df.isna().sum().sort_values(ascending=False).head(10)

#Cuantificar los faltantes más relevantes

df.isna().mean().sort_values(ascending=False).head(20)

# Filtrar variables útiles (con pocos faltantes)

# Filtramos las columnas con menos del 20% de NaN
df_reducido = df.loc[:, df.isna().mean() < 0.2]
print("Columnas retenidas:", df_reducido.shape[1])

# # Subir el archivo al entorno de Colab (Libro de códigos)

from google.colab import files
uploaded = files.upload()

# Cargar el archivo y mirar su estructura
import pandas as pd

codigos = pd.read_excel("libro-de-codigos-emse-2018.xlsx")
codigos.head(30)

# 3️Verificar los nombres de las columnas

codigos.columns

# Ver los nombres de columnas tal cual están
codigos.columns.tolist()

# Buscar columnas que contengan la palabra “pregunta”
[c for c in codigos.columns if "preg" in c.lower()]

# Usar ese nombre automáticamente (sin tener que escribirlo)

# Buscar la columna que contenga la palabra 'pregunta'
col_preg = [c for c in codigos.columns if "preg" in c.lower()][0]
print("Nombre detectado de la columna:", col_preg)

# Extraer los nombres de variables desde esa columna
nombres_vars = codigos[col_preg].dropna().unique().tolist()

print("Total de variables:", len(nombres_vars))
print("Primeros 20 nombres:", nombres_vars[:20])

# Comparar variables del libro con las columnas del dataset
vars_existentes = [v for v in nombres_vars if v in df.columns]

print("Variables del libro presentes en la base:", len(vars_existentes))
print(vars_existentes)

# Detección y extracción de preguntas (para Excel)
import pandas as pd

# 1. Cargar el libro de códigos completo
# (read_excel no tiene skip_blank_lines, así que simplemente cargamos todo)
codigos_raw = pd.read_excel("libro-de-codigos-emse-2018.xlsx", header=0)

print("Columnas detectadas en el archivo:")
print(codigos_raw.columns.tolist())

# 2. Detectar automáticamente la columna que contiene las preguntas
col_pregunta = None
for col in codigos_raw.columns:
    ejemplos = codigos_raw[col].dropna().astype(str).head(15)
    if any("?" in e for e in ejemplos):  # detectar signos de pregunta
        col_pregunta = col
        break

if col_pregunta:
    print(f"\nColumna detectada como 'Pregunta': {col_pregunta}")
else:
    print("\nNo se encontró columna con texto de pregunta. Verificar manualmente los encabezados.")

# 3. Detectar la columna de los códigos de variable (q1, q2, etc.)
# Buscar columnas que contengan 'arg', 'preg' o 'variable'
col_codigo = [c for c in codigos_raw.columns if any(x in c.lower() for x in ["arg", "preg", "variable"])][0]
print(f"Columna detectada como 'Código de variable': {col_codigo}")

# 4. Filtrar solo las filas que contienen tanto el código como el texto de pregunta
codigos_filtrado = codigos_raw[[col_codigo, col_pregunta]].dropna()

# 5. Renombrar columnas para mayor claridad
codigos_filtrado.columns = ["Variable", "Descripcion"]

# 6. Limpiar duplicados y espacios en blanco
codigos_filtrado = codigos_filtrado.drop_duplicates().reset_index(drop=True)
codigos_filtrado["Variable"] = codigos_filtrado["Variable"].astype(str).str.strip()
codigos_filtrado["Descripcion"] = codigos_filtrado["Descripcion"].astype(str).str.strip()

# 7. Mostrar un resumen del diccionario generado
print(f"\nDiccionario limpio generado: {codigos_filtrado.shape[0]} variables encontradas\n")
display(codigos_filtrado.head(30))

# Bloque para unir el libro de códigos con la base de datos

# 1. Tomar las variables que realmente están presentes en el DataFrame principal
vars_existentes = [v for v in codigos_filtrado["Variable"] if v in df.columns]

print(f"Variables presentes en la base: {len(vars_existentes)}")

# 2. Filtrar el diccionario original para conservar solo las variables existentes
diccionario_final = codigos_filtrado[codigos_filtrado["Variable"].isin(vars_existentes)].reset_index(drop=True)

# 3. Mostrar un resumen de las variables activas
print(f"\nDiccionario final de variables activas: {diccionario_final.shape[0]} variables encontradas\n")
display(diccionario_final.head(15))

# Bloque sugerido de código para explorarlas todas
pd.set_option('display.max_rows', None)
display(diccionario_final[['Variable', 'Descripcion']])

# Crear en Colab un subconjunto con esas variables y renombrarlas:

vars_finales = ['q1','texto_q1','q2','texto_q2','q3','texto_q3','q6','texto_q6',
                'q10','texto_q10','q15','texto_q15','q22','texto_q22',
                'q27','texto_q27','q35','texto_q35','q59','texto_q59']

sub_df = df[vars_finales].copy()

# Renombrar columnas para análisis legible
sub_df = sub_df.rename(columns={
    'texto_q1':'Edad',
    'texto_q2':'Sexo',
    'texto_q3':'Grado',
    'texto_q6':'Actividad_fisica',
    'texto_q10':'Consumo_frutas',
    'texto_q15':'Lesiones',
    'texto_q22':'Tabaco',
    'texto_q27':'Amigos_cercanos',
    'texto_q35':'Alcohol',
    'texto_q59':'Educacion_padres'
})

# Verificar estructura del DataFrame nuevo
sub_df.info()
# Verificar los nombres de las columnas
sub_df.columns.tolist()
# Mostrar una muestra aleatoria
sub_df.sample(5)

# Trabajar sólo con las columnas textuales
cols_textuales = ['Edad', 'Sexo', 'Grado', 'Actividad_fisica',
                  'Consumo_frutas', 'Lesiones', 'Tabaco',
                  'Amigos_cercanos', 'Alcohol', 'Educacion_padres']

df_analisis = sub_df[cols_textuales].copy()
df_analisis.head()

# ============================================
# BLOQUE: Estadística descriptiva y gráficos
# ============================================

import matplotlib.pyplot as plt
import seaborn as sns

# Configuración general
plt.style.use('seaborn-v0_8-whitegrid')
sns.set(font_scale=1.1)
plt.rcParams['figure.figsize'] = (8, 5)

# 1. Estadística descriptiva básica
print("Resumen general de las variables categóricas:\n")
for col in df_analisis.columns:
    print(f"{col}: {df_analisis[col].nunique()} categorías | {df_analisis[col].isna().mean():.1%} valores faltantes")
    print("Moda:", df_analisis[col].mode().values[0])
    print("-" * 50)

# 2. Distribución por sexo
sexo_counts = df_analisis['Sexo'].value_counts(normalize=True) * 100
sns.barplot(x=sexo_counts.index, y=sexo_counts.values, palette="pastel")
plt.title("Distribución por sexo (%)")
plt.ylabel("Porcentaje")
plt.xlabel("")
plt.show()

# 3. Distribución de edad
edad_counts = df_analisis['Edad'].value_counts().sort_index()
sns.barplot(x=edad_counts.index, y=edad_counts.values, palette="crest")
plt.title("Distribución de edades (en años)")
plt.ylabel("Frecuencia")
plt.xlabel("Edad")
plt.show()

# 4. Nivel educativo de los padres
edu_counts = df_analisis['Educacion_padres'].value_counts().head(6)
sns.barplot(y=edu_counts.index, x=edu_counts.values, palette="flare")
plt.title("Nivel educativo de los padres (principales categorías)")
plt.xlabel("Frecuencia")
plt.ylabel("")
plt.show()

# 5. Hábitos de salud (actividad física y consumo de frutas)
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

sns.countplot(data=df_analisis, y='Actividad_fisica', order=df_analisis['Actividad_fisica'].value_counts().index, ax=axes[0], palette="Blues_r")
axes[0].set_title("Frecuencia de actividad física")

sns.countplot(data=df_analisis, y='Consumo_frutas', order=df_analisis['Consumo_frutas'].value_counts().index, ax=axes[1], palette="Greens_r")
axes[1].set_title("Consumo de frutas en los últimos 7 días")

plt.tight_layout()
plt.show()

# 6. Conductas de riesgo (tabaco y alcohol)
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

sns.countplot(data=df_analisis, y='Tabaco', order=df_analisis['Tabaco'].value_counts().index, ax=axes[0], palette="Reds_r")
axes[0].set_title("Frecuencia de consumo de tabaco")

sns.countplot(data=df_analisis, y='Alcohol', order=df_analisis['Alcohol'].value_counts().index, ax=axes[1], palette="Oranges_r")
axes[1].set_title("Frecuencia de consumo de alcohol")

plt.tight_layout()
plt.show()

# ============================================
# FIN DEL BLOQUE
# ============================================